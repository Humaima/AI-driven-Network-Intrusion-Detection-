# -*- coding: utf-8 -*-
"""AI-Driven Network Intrusion Detection System (NIDS).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ROG-wqtXC1z9hME71JznY7Z3GUzt73ln
"""

# Import Libraries
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_curve, auc
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import plotly.express as px
import matplotlib.pyplot as plt
import time
from sklearn.datasets import fetch_kddcup99

# Load Dataset
data = fetch_kddcup99(as_frame=True, percent10=True)
df = data.frame

st.title("ðŸ“¶ Network Intrusion Detection System (LSTM Model)")
st.write("### Sample Data")
st.dataframe(df.head())

# Data Preprocessing
columns = ['duration', 'protocol_type', 'src_bytes', 'dst_bytes', 'flag', 'labels']
df = df[columns]

# Encode Categorical Variables
encoder = LabelEncoder()
df['protocol_type'] = encoder.fit_transform(df['protocol_type'])
df['flag'] = encoder.fit_transform(df['flag'])

# Features and Target
X = df.drop('labels', axis=1)
y = (df['labels'] != 'normal').astype(int)  # Binary target: 1 for intrusion, 0 for normal

# Scale Numeric Features
scaler = StandardScaler()
X[['duration', 'src_bytes', 'dst_bytes']] = scaler.fit_transform(X[['duration', 'src_bytes', 'dst_bytes']])

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Reshape Data for LSTM
X_train_lstm = np.expand_dims(X_train, axis=1)  # Shape: (num_samples, 1, features)
X_test_lstm = np.expand_dims(X_test, axis=1)

# Build LSTM Model
lstm_model = Sequential([
    LSTM(64, input_shape=(1, X_train.shape[1]), return_sequences=True),
    Dropout(0.2),
    LSTM(32),
    Dropout(0.2),
    Dense(1, activation='sigmoid')
])

# Compile the Model
lstm_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the Model
st.write("### Training the LSTM Model...")
history = lstm_model.fit(X_train_lstm, y_train, epochs=5, batch_size=64, validation_data=(X_test_lstm, y_test))

# Prediction for User Input
st.sidebar.header("ðŸ”§ Enter Input Parameters")
default_input = "0,1,100,200,0"  # Example input
user_input = st.sidebar.text_input("Enter Network Data (comma-separated):", default_input)

try:
    # Convert user input to numpy array and reshape for prediction
    input_data = np.array(user_input.split(',')).astype(float).reshape(1, X_train.shape[1])
    input_data[:, :3] = scaler.transform(input_data[:, :3])  # Scale numeric fields
    input_data_lstm = np.expand_dims(input_data, axis=1)

    # Predict with LSTM model
    lstm_prediction = lstm_model.predict(input_data_lstm)[0][0]
    st.write("### Prediction Result")
    if lstm_prediction > 0.5:
        st.error("âš ï¸ Intrusion Detected!")
    else:
        st.success("âœ… Normal Traffic")
except ValueError as e:
    st.error(f"Invalid input: {e}")

# Evaluate the Model
st.write("### Model Performance on Test Data")
lstm_eval = lstm_model.evaluate(X_test_lstm, y_test, verbose=0)
st.write({"Accuracy": lstm_eval[1], "Loss": lstm_eval[0]})

# Classification Report
y_test_preds = (lstm_model.predict(X_test_lstm) > 0.5).astype(int).flatten()
report = classification_report(y_test, y_test_preds, output_dict=True)
st.json(report)

# ROC Curve
lstm_probs = lstm_model.predict(X_test_lstm).flatten()
fpr, tpr, _ = roc_curve(y_test, lstm_probs)
roc_auc = auc(fpr, tpr)

fig, ax = plt.subplots()
ax.plot(fpr, tpr, label=f"LSTM (AUC = {roc_auc:.2f})")
ax.plot([0, 1], [0, 1], linestyle='--', color='gray')
ax.set_title("ROC Curve")
ax.set_xlabel("False Positive Rate")
ax.set_ylabel("True Positive Rate")
ax.legend()
st.pyplot(fig)

# Real-Time Traffic Monitoring Simulation
st.subheader("ðŸ“Š Real-Time Network Traffic Monitoring")
traffic_data = np.random.randn(100)  # Simulate random traffic data
chart = st.line_chart(traffic_data)

# Simulate Updates
for _ in range(100):
    new_data = np.random.randn(1)
    traffic_data = np.append(traffic_data[1:], new_data)
    chart.add_rows([new_data])
    time.sleep(0.1)